Fighting Game APIInitial Fighting Game APIFighting Game Genre:  Our genre consists of any 2D game that has a user controlled character (or multpitle user controlled characters) who interacts with his environment via running, jumping, and -most importantly to our genre- throwing attacks.  Therefore, the basic distinctions that must be made are what constitutes a character, the inanimate environmental objects, and the animate environmental objects (AI). The user controlled character therefore should be able to run on top of inanimate objects, but not be able to run on top of animate objects.  Conversely, he should be able to attack (and be attacked by) animate objects, but not be able to attack/ do damage to inanimate objects.  There are many more subtleties to this situation, and therefore we have created many interfaces, which you may read about in detail below, in order to handle all of the situations we forsaw.Design Goals:  The goal of our design is to be able to create a Fighting Game API from which a game developer will have the freedom to create a variety of different styled fighting games (eg. SuperSmashBros, StreetFighter) , both single player and multiplayer (on a single console, not across the network).  Our API easily supports modifying or creating new characters, modifying or creating new levels, modifying or extending the game rules and goals for each level. Here, game rules and fighting action are similar labels, as the primary game rules depend on how the fighting action transpires- whether it is a damage based game, a hits based game, or a more complex derivative of one of these two options.We have split our API up using the Model View Controller paradigm.In the View, we have a single package, the View package, which will receive information from the Model via the Controller.  The View (and Controller) gives the designer the freedom to choose how all of the objects are displayed.  As we will see below, all the Game Developer must do is provide the View with the proper xml file to link all of the game objects to the desired images they should paint.The Controller will keep track of all of the different modes, which constitute the current GameInstance, SplashScreen, or Menu mode being updated with user input.  The controller will handle the timer and running of the game, and will be responsible for appropriately switching any given mode at any given time, meaning it will be responsible for the level progression  It will also be for loading and setting up the game, as well as saving the User information that is generated during the course of play.  The design of the Controller is to minimize the amount of code a game designer needs to write in order to have a running game.  The Controller takes all responsibility of transferring painting information to the View, as well as updating the proper mode.  As we will see below, all the Game Developer must do is provide the Controller with the proper xml file to generate levels as well as their progression.  What is incredibly extensible for the Developer are both the game rules as well as the game goals.  The goals are defined implicitly in how each mode decides to regulate switching to the next mode (which is defines the goals, as winning takes you to the next level and losing restarts/take you to the main menu mode).Roles and Responsibilities:View: Wayne, Bill, ThomasController: Jack, Matt, JerryModel: Jimmy, David, AlanPhysics: WayneModel Side:In the Model, we will have a Mode package, which is where all mode-specific implementation details are contained. These objects interface with the Controller’s subcontroller objects in response to game state manipulations from controller input or propagations of those manipulations through the game loop. We will also have an Object package to support all types of objects in any given mode. Finally we will have a Physics Package which will be used to abstractly mediate these object interactions.  As we will see below, all the Game Developer must do is provide the Model the proper xml file to link create all of the desired Characters/ Environmental Objects. Additionally, the developer has the option to extend the Mode superclass if there exists a need for additional types of modes.Mode PackageThe mode package is used to store the Mode superclass and its subclasses that handle interfacing with the controller for every type of mode.We are using the Mode superclass to hold all the game objects of a certain mode and provide interfacing methods with the appropriate subcontroller. The superclass contains all objects in the mode, as well as a few basic methods common to all modes.The superclass is extended by subclasses that implement additional functionality for the specific mode. For instance, for a level we want to end the mode when a player has been defeated, whereas for a menu we want to end the mode when the appropriate selections have been made./*** Contains all game objects in the mode and handles basic interaction with the appropriate* subcontroller. Extended by subclasses for specific modes.*/public abstract class Modeprivate Set<GameObject> myObjects;private long myId;/*** Returns the id of the mode.*/public long getMyId()/*** Returns the list of objects for this mode.*/public Set<GameObject> getMyObjects()/*** Add an object to the list of game objects.*/public void addObject()/*** Remove an object from the list of game objects.*/public void removeObject(GameObject object)/*** Handles all initialization details when the mode is loaded by the appropriate subcontroller. This* method should be called first by the subcontroller.*/public abstract void initializeMode()/*** Notifies the subcontroller that the mode should terminate. Implementation details subject to* change, but essentially this method will be called when the mode has finished. Specific rules* for when the mode should be terminated are implemented in subclasses.*/public void signalTermination()We expect that there are certain types of modes that a game developer would like to use, and so we provide a few implementations of Mode subclasses for the developer./*** Mode class implementation for a level, i.e. a match between two or more characters on a map.*/	public class LevelMode extends Modeprivate ObjectLoader myLoader;private CollisionManager myCollisionManager;/*** Overrides superclass initialize method by creating all objects in the level.*/public void initializeMode() {	loadMap(long mapId)	loadCharacters(List<Long> characterIds)}/*** Updates level mode by calling update in all of its objects.*/public void update() {	Set<GameObject> myObjects = getMyObjects()	handleCollisions()	for (GameObject object : myObjects) {		object.update()	}      for (GameObject object : myObjects) {		object.updateState()	}}/*** Loads the environment objects for a map using the ObjectLoader.*/public void loadMap(long mapId) {	// load the environment objects using the object loader}/*** Loads the character objects for the selected characters using the ObjectLoader.*/public void loadCharacters(List<Long> characterIds) {	// load the character objects using the object loader}		/*** Detects and handles collisions between game objects.*/	public void handleCollisions()	{	// pass in our list of objects to collisionManager}/*** Mode for handling a level editor, i.e. a tool for building user-created maps*/public class LevelEditorMode extends Modeprivate ObjectLoader myLoader;private CollisionManager myCollisionManager;/*** Overrides superclass initialize method by creating all objects in the level.*/public void initializeMode() {	// can either initialize a new map or load an existing one, call either createNewMap() or	// loadMap() as appropriate	createNewMap() / loadMap()}/*** Updates level mode by calling update in all of its objects.*/public void update() {	Set<GameObject> myObjects = getMyObjects()	handleCollisions()	for (GameObject object : myObjects) {		object.update()	}}/*** Loads the environment objects for a map using the ObjectLoader.*/public void loadMap(long mapId) {	// load the environment objects using the object loader}		/*** Detects and handles collisions between game objects.*/	public void handleCollisions()	{	// pass in our list of objects to collisionManager}Physics PackageThis package contains the physics class which calculates physics based interactions and the utilities needed for such calculations/*** Handles physics calculations for the game engine.*/public class PhysicsContains several methods for various interactions (elastic collision, inelastice collision etc.) as well as forces (gravity, friction) that act upon game objects.Vector implements CloneableClass that represents a mathematical vector as a direction and magnitudeThis class has no relation to java.util.Vector!This class contains various methods that return values, set values, perform arithmetic on values etc.Object PackageThe representation of all objects in the game, including characters, items, environment blocks, etc. is handled in the object package. Specifically, the API is designed in a hierarchy with GameObject at the top. Underneath this are the subclasses CharacterObject, AttackObject, and EnvironmentObject, which represent specific types of game objects. We will also add other object types for menu screens and other modes such as MenuObjects./*** Superclass of all objects in the game including characters, items, environment blocks, etc.* Contains object data such as instance ID, object ID, hitbox, location, and image.*/public abstract class GameObject;private long myInstanceIdprivate long myObjectIdprivate UpdatableLocation myCenterprivate ImageDataSource myImageDataprivate Map<String,State> myStatesprivate Map<String,Integer> myProperties/*** Generates a unique instance ID for the object. Ideally should be called during construction.*/public long generateId()/*** Returns the game object's instance id. This id is unique to this particular* instantiation of the object.*/public long getInstanceId()/*** Sets game object's center.*/public void setLocation(UpdatableLocation ul)/*** Returns game object's center.*/public UpdatableLocation getLocation()/*** Returns a property for this object. Returns -1 if property does not exist.*/public int getProperty(String key)/*** Clears all properties.*/public void clearProperties/*** Adds a state for this object. Overwrites any existing value.*/public void addState(String key, State value)/*** Sets the current state for this object. Resets the current state after* switching.*/public void setCurrentState(String key)/*** Sets image data for this object. Size, Location, and Image must not be* null for this object before calling this method, otherwise, this method* returns null.*/public void setImageData()public void setImageData(ImageDataObject image){/*** Returns image data for this object.*/public ImageDataObject getImageData()/*** Returns image data for this object.*/public ImageDataObject getImageData()/*** Updates the object for the game loop. Should be overridden by subclasses if* necessary, but all overrides should first call superclass method.*/public void update()/*** Updates the objects state for the game loop. States are updated separately* because all states must be updated together, either before or after other* update logic that depends on current states.*/public void updateState()/*** Checks an intersection with another object. Collision checking is conducted via hitboxes.*/public boolean collidesWith(GameObject other)/*** Represents characters in the fighting game. Properties and attacks of the character are stored* in private Maps. Currently active effects are stored in a private List, and other values such as* health and location are stored in pointers to specialized objects that handle that data.*/public class CharacterObject extends GameObjectprivate Map<String, AttackObject> myAttacks;private List<Effect> myActiveEffects;private Health myHealth; private List<AttackObject> currentAttacks; private boolean facingRight;  private int movingDirection; /*** Updates the character for one game loop cycle. Applies movement from acceleration* forces acting on the character.*/public void update()/*** Calls GameObject's updateState() method as well as sets the default state to stand* if no other state actions are going on.*/public void updateState()/*** Adds an effect to the list of active effects.*/public void addActiveEffect(Effect toAdd)/*** Returns list of currently active effects on this character.*/public List<Effect> getActiveEffects()/*** Adds an AttackObject to the list of attacks available for this character.* Note that this attack will not be added to the list of game objects in a* level, thus it will not update and should be used solely for generating* other attack objects as needed. Overwrites any existing attack.*/public void addAttack(String key, AttackObject object)/*** Creates and returns an attack object based on a given identifier. Returns null* if the specified attack does not exist.* * Note: For now just using String to represent attack types, but this is obviously* subject to change.*/public AttackObject createAttack(String key)/*** Returns the health of the character.*/public Health getHealth()/*** Returns whether or not the character has remaining health.*/public boolean hasHealthRemaining()/*** Sets the health of the character*/public void setHealth(int amount)/*** Changes the player's health by a given amount. Positive input raises it, and* negative input decreases it. Returns health remaining.*/public int changeHealth(int amount)/*** Creates an attack by consulting with the map of attacks and getting a copy of the appropriate* AttackObject.*/public void attack(String key)/*** Moves in given direction at speed of character*/public void move(int direction)/*** Gets the direction the character is moving*/public int getMovingDirection()/*** Characters should never be removed.*/public boolean shouldBeRemoved()/*** Checks to see if character is facing right*/public boolean isFacingRight()/*** Sets the character to face left */public void faceLeft()/*** Sets the character to face right */public void faceRight()/*** Returns list of all attackObjects*/public List<AttackObject> getAttackObjects()/*** Represents attacks by characters. Each character holds an initial collection of these in a map* and clones those attacks when actually attacking; thus, one AttackObject represents one* individual attack.*/public class AttackObject extends GameObjectprivate Counter myCounter;private GameObject myOwner;private List<Effect> myEffects;/*** Creates a deep copy of another AttackObject's state map and sets it as this* object's state map.*/public void copyStates(AttackObject other)/*** Move the attack object to the position of its owner.*/public void moveToOwner()/*** Updates the attack object by calling GameObject’s update, moving, and by decreasing it’s time* remaining so that it can expire if its time is up.*/public void update()/*** Move attack object by its designated velocity*/public void move()/*** Adds an effect to myEffects.*/public void addEffect(Effect effect)/*** Returns the list of effects carried by this object.*/public List<Effect> getEffects()/*** Gets the character who created the attack*/public GameObject getOwner()/*** Inflicts damage upon a target player.*/public int inflictDamage(CharacterObject target)/*** Applies all effects of this AttackObject to a target. Note that if one AttackObject applies its* effects to multiple targets, each target will hold a unique copy of the effect.*/public void addTargetForEffects(CharacterObject target)/*** Sets the counter to the current amount */public void setCounter(int amount)/*** Returns true if this attack object has expired.*/public boolean shouldBeRemoved()/*** Represents an environment object such as a platform. Designated by the data* of each map.*/public class EnvironmentObject extends GameObject/*** Map class to contain, update, and manipulate all environmental objects in a* particular map. Also contains the background image, music, and player start* locations.*/public class MapObject extends GameObject {private List<EnvironmentObject> myEnviroObjects;private List<UpdatableLocation> myStartingPositions;private Map<String,Sound> mySounds;private Sound myCurrentSound;/*** Adds an environment object to the map object.*/public void addEnviroObject(EnvironmentObject object)/*** Returns the list of environment objects in the map object.*/public List<EnvironmentObject> getEnviroObjects()/*** Clears all environment objects from the map object.*/public void clearEnviroObjects()/*** Adds a starting position to the map object.*/public void addStartPosition(UpdatableLocation position)/*** Returns the list of starting positions from the map object.*/public List<UpdatableLocation> getStartPositions()/*** Adds a sound to the map object. Overwrites any existing value.*/public void addSound(String key, Sound sound)/*** Clears all sounds from the map object.*/public void clearSounds()/*** Sets the current sound of the map object. Does nothing if the given key is* not found in the map.*/public void setCurrentSound(String key)/*** Returns the current sound of the map object.*/public Sound getCurrentSound()/*** Begins playing the current sound.*/public void playCurrentSound()/*** Updates all environmental objects in the map object. */public void update()Object Utils PackageThe objects package also refers to a series of utils in its own utils package. These utils are created for the purpose of maintaining a delegation design pattern. Specific behaviors common to different types of objects would be the focus of these objects, and game objects would be aggregations of these objects, as well as methods for manipulating them. The behavior of these classes is pretty much what one would expect, so this document will not list out specific methods; however, the list is as follows:1) Health - holds a health value and provides methods for setting, modifying, and checking the current health value. Health cannot be negative.2) Counter - holds a count that can be set and decremented. This class was created as a sort of timer that counts in terms of game loops; thus, the counter would have to be decremented every game loop. This decrement is done in the update method.3) Hitbox - holds a series of rectangles representing hitboxes for an object. This class contains methods that progress to the next hitbox in the list, which are called in its update method. Additionally, this class holds methods for maintaining hitbox priority.4) Animation - holds a series of images representing one animation for an object. This class, much like the hitbox class, takes care of the current frame of an animation and progresses through the animation in its update method. This class also manages depth, i.e. which animations should be drawn on top of others in the event that they collide.5) Effect - holds data for a specific effect and how it affects characters. This class contains an update method that modifies its target’s state according to the rules of the effect. Note that one Effect can only have one target, and thus if an effect is meant to be applied to multiple targets, it must be cloned.CollisionManagerThe new CollisionManager class is located within the model and uses reflection to determine the runtime types of colliding objects in order to call the appropriate collide methods. This system replaced the older implementation of the visitor framework. Despite taking a performance hit, using reflection gives us massive advantages in ease of extension and code organization.public class CollisionManager/*** Checks collisions between all objects in a list.*/public void checkCollisions(List<GameObject> myObjects) {       for (int i = 0; i < myObjects.size() - 1; i++) {           for (int j = i + 1; j < myObjects.size(); j++) {               GameObject o1 = myObjects.get(i);               GameObject o2 = myObjects.get(j);               if (o1.checkCollision(o2)) {                   handleCollisions(o1, o2);               }           }}/*** Uses reflection to call the correct collide method.*/public void handleCollisions(GameObject o1, GameObject o2) {       try {                     	Class<?>[] runtimeClasses = new Class[]{o1.getClass(), o2.getClass()};        	Object[] parameters = new Object[]{o1, o2};Method method = this.getClass().getMethod("collide", runtimeClasses);           method.invoke(this, parameters);       } catch (NoSuchMethodException e) {	// exception handling       }}/*** Handles a collision between two types of GameObjects.*/public void collide(GameObject o1, GameObject o2) {     // specific collision handling logic goes here}Note that the collide() method is repeated numerous times here with different input parameters, which handle collisions between two different types of objects.Util Package/*** Represents an image.*/public class Sprite;/*** Represents a location on a coordinate plane.*/public class Location;/*** Represents a vector.*/public class Vector;/*** Represents a sound.*/public class Sound;/*** Represents a square dimension.*/public class Dimension;/*** An interface representing GameInstance, SplashScreen, or Menu mode*/Controller Package The Controller Package is the connection point between the Model Module and the View.  The GameManager class itself encapsulates the entire game, including both the Model and View.  To start the game, one only needs to use the GameManager’s method run(), which starts the game loop.  Different game states (main menu, character selection menu, a level, etc.) will each have a Controller-Mode pair. To better understand the game loop, we must first describe the other classes in the controller package.  There is the ControllerManager class, which handles level switching. There is the ControlProgressionManager class, which handles level progression. There is the ControllerFactory, which handles creation of controller objects. We have the GameInfo class, which controllers add to and use to initialize modes. DisplayInfo class updates game stats and dynamic game information. Finally, there are the interfaces. The Canvas derives painting information from the class that implements the ViewDataSource interface. In this case, its the DisplayInfo classes and subclasses. ControlDelegate interface is implemented by the ControllerManager. The ControllerManager passes itself down to each controller as a ControlDelegate. When the controller-mode pair reaches a certain state (game over for instance), it calls a notifyEndCondition(String string) method from ControlDelegate. This tells the delegate (ControllerManager) to switch controllers based on the condition that’s passed. Each specific Controller subclass has a Mode attached to it. So for an example: A MainMenuController subcontroller that extends MenuController that extends Controller, has a MenuMode attached to it. A CharacterSelectMenuController subcontroller also has a MenuMode attached to it. However, a OneVOneController has a LevelMode attached to it. The Modes are initialized in each controller.public class GameManager 	public void run()         // starts the game loop, which entirely contains the game.	public Component CreateView()     // returns the Canvas, which Extends component           	The GameManager is what’s instantiated in Main, and essentially starts off the Game. It loads the ControllerManager, ControllerProgressionManager, and the possible maps. The GameManager is also responsible for interacting with the Arcade.public class ControllerManager(Canvas frame, GameInfo gameinfo, ControllerFactory factory, ControlProgressionManager progressionmanager)  implements ControllerDelegate		The ControllerManager is handles the switching controllers. It uses a ControllerFactory, which uses reflection to create all controllers based on a resource file, to get a map of controllers. Controllers are instantiated with no parameters at first. When the ControllerManager switches to a controller, it essentially switches to a controller already generated, and initializes that controller with the proper parameters (canvas, gameinfo, itself as a delegate). 	public void switchController(String condition)public class ControllerFactory(Canvas canvas) 		Uses reflection to generate controllers from a resource file. Stores the generated controllers in a Map<String, Controller> where the string is the controller name also gotten from the resource file. So if the resource file reads:MainMenuController = MainMenuThe ControllerFactory will generate a MainMenuController and initially initialize that controller with “MainMenu” as its name. It then puts it into a map. 	public void constructControllerMap()      public Controller createController(String controllerName)	public class ControlProgressionManager	The ControlProgressionManager is instantiated in the ControllerManager, and essentially contains the logic of switching controls. So when ControllerManager uses its own switchController method, it calls the ControlProgressionManager’s getNextController(String condition) method, which returns the proper controller. Any sort of tournament switching algorithm is also contained in here. 	public Controller getNextController(String condition)public class Controller 		The controller handles the behavior of the game. It handles input and passes information from the Mode to the View to paint. The controller also handles winning conditions of game. First the controller loads the Mode by using GameInfo. After the mode has been loaded, it creates a DisplayInfo class using the mode generated. Then it sets this DisplayInfo class as a ViewDataSource. This allows the Canvas to paint information in the DisplayInfo class. The controller then updates its itself, its mode, its display info, and repaints. This class is the heartbeat of the game. public class GameInfo	GameInfo holds all the information necessary to start (initialize the game mode). So it holds the type of game (1v1, 2v2), which map etc. GameInfo is passed into the mode so the mode can load everything needed to initialize the game. Once the game is loaded, stats are updated in DisplayInfo and its subclasses. GameInfo merely contains information to start the game. GameInfo has information added to it by each menu. So for an example, when the game is CharacterSelectMenuController and MenuMode, a user would click a character and the Controller would add the character name (used to load character stats from XML later) into GameInfo. Similarly with maps in MapSelectController. Once GameInfo has enough information to start a game, it gets passed into a LevelController, which uses its information to initialize a LevelMode. public class DisplayInfo extends Observable implements ViewDataSource	Display info contains all dynamic information of the game such as health, score, and the “graphics” of the game (images of the characters, platforms etc.). The controller sets this class and its subclasses (DisplayLoopInfo, GameLoopInfo) as a ViewDataSource so the Canvas can paint relevant information.public interface ViewDataSource	Interface implemented so Canvas can paint informationpublic interface ControlDelegate			View Package      The view has two main classes and a factory class which utilizes annotations. The first class is the Canvas, which represents the paintable region. The Canvas requests from the Controller a list of Paintable Objects along with coordinates in the form of a Point2D. The Canvas then tells the objects to paint themselves. The Canvas can be extended to create layouts where the Canvas subclass expects, at minimum, a set of Paintable Objects that will be told to paint themselves in set locations, e.g. a MenuCanvas would paint the objects in a list down the center and ignore the coordinates given, or a StockMatchCanvas would have locations set for a timer and player stats.	The other main class for the View is HUDElement. HUDElement represents a static display on-screen which displays information about some value in the Model. This can be a health bar, a score, a name, a life counter, a timer, etc. These implement Observer and use reflection to observe a particular value within an instance of a class. This means that the values tied to the element would update themselves. Although these can be instantiated manually, they are closely tied to an Annotation called HUDVariable. HUDVariable is an annotation for member variables of Observable objects. It has two fields, Name and HUDElementClass. Name defines the name used to represent this member to the view, how it is used is purely up to the specific HUDElement. HUDElementClass defines which HUDElement is being instantiated to display the variable e.g. “HealthBar” would instantiate a HUDHealthBar object observing the object. These annotations are read by HUDFactory which has a single static method that takes in an object, reads the annotations, and returns a list of instantiated HUDElements.	In order to provide a barrier between the HUDElements and the Model, the HUDElements can be set to observe a private class in the subcontroller. This class would be updated by the subcontroller and allow the subcontroller to keep all displayed data in a single location for future changes.	Each HUDElement will be documented with what type of data it is expecting and an example image. It is expected that the developer will create subclasses of HUDElement and use a relevant annotation within the controller. This way, the developer can either use existing functionality or extend it with relative ease.	To provide a way of managing the way particular objects are drawn, there is a CanvasLayout class which overrides the Canvas’ draw method. It is expected that the developer would check Paintables using instaceof and draw the objects in a particular manner, e.g. in the FourPlayerMatchGameLayout. However, the developer has complete freedom on how to draw the given objects.The View Packagepublic class Canvas	public Canvas (Dimension size)		\\Makes a canvas with appropriate dimensions	public void paintComponent (Graphics pen)		\\Queries Controller for Paintable information and then paint the		\\ objects appropriately. Called by Java.public abstract class HUDElement implements Observer, Paintable	public void setName (String name)		\\Sets myName to the given value	public void setObservedValue (String fieldName)		\\Sets the name of the member field of the observed object, should be		\\ received via reflection.	protected Object getObservedValue (Object o) throws SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException		\\Gets the value of the member variable being observed. Uses		\\ reflection which creates many possible exceptions.	public void setLocation(double x, double y)		\\Sets the location of the element	public void setLocation(Point2D location)		\\Sets the location of the elementpublic @interface HUDVariable	public String name()		\\The representative name of the variable	public String HUDElementClass()		\\The name of the HUDElement being used to represent the value.public class HUDFactory	public static List<HUDElement> getHUDElements (Observable gameObject) throws InstantiationException, IllegalAccessException, ClassNotFoundException		\\Generates a list of HUDElements based off of annotations found      \\  in the objectpublic class LevelCanvas extends Canvas	public void paintComponents (Graphics pen)		\\Overrides to provide default locations for a HUDTimer,      \\ a HUDLogo, 1-4 HUDPlayerDamage objects, and      \\ 1-4 HUDPlayerLives objectsconfig Package	This package contains the relevant xml and .properties files used to load objects and controllers, as well as contains the mappings for inputs. 	For the Game Developer:Possible Extensibility when creating a Fighting game:Entry points into code:  Subclassing Controller, which deals with almost all running codeor subclassing GameManager, which is encompassed the entire code framework, above the scope of an individual controller.  Most changes are made via subclassing the first class, as we will describe below.To use our framework to create a game, a Game Developer would only need to subclass a controller, add that controller to the FightingManifesto file. Inside the subclassed controller, the developer would define his/her winning conditions, special conditions, and inputs. Of course, if the developer wanted to add inputs, he would add the inputs in the input file mapping. For an example, if the game developer instead wanted to make a platformer out of our fighting game, he/she simply would need to subclass the controller (level1, level2, or jungleLevel, iceLevel) and inside these controllers, and add the characters they want in the level GameInfo. If a dev wanted to create a new GameObject with specific health, attack etc, he/she can edit the character XML  (or menu xml, if they want to make menus) as detailed below. As far as the controller side goes, a developer merely needs to:Subclass a controller and add that controller to FightingManifesto (ex: JungleController = jungle).  Which controller they choose to subclass really depends on how much functionality they plan to modify/extend:Should they want to create a new menu screen, they should subclass MenuController, looking at any of our examples (MainMenuController, CharacterSelectController) to see how specific methods are implemented (or just keep reading!).  When subclassing the MenuController, one can write new input methods for the controller (using the Input team’s framework), change the Menu Switching conditions by overwriting the checkConditions Method, as well as using the setupConditions/ addCondition methods to set up unique conditions for switching based on Mode gamestate.  A game developer should also implement the method notifyEndCondition and pass the string representation of the next Controller to the ControllerManager’s notifyEndCondition.  Please look at the MainMenuController for a good example of how this is done.  Typically, the next Controller’s representation is given by the getNext() method of the Menu Object that has been clicked on.  As of now, the MenuController is setup to handle clicking on a given menu object, which returns to the Mode the given choice, which the controller can then grab with getMode().getChoice, and therefore the controller can also access the MenuObject by calling    getMode.getMenu(getMode().getChoice), as the MenuMode has this method to return a given menu based on the choice.  As this is a bit of a confusing explanation, please look into the MainMenuController for a concrete guide. It’s less confusing in the code :)If they want to create a new type of gameplay, they should most likely subclass LevelController, as this controller deals strictly with the LevelMode, and gives the following flexibility:Defining Winning Conditions:Creating SpecialConditions - Like low health mode/no gravity modeThese are done by simply overwriting the setupConditions method, writing an in line anonymous class using the ModeCondition interface, and then adding this inline class to either the WinConditions or SpecialConditions list (using the appropriate given add method).  Then one must override the checkConditions, and can implement basically anything they want manipulating, ending, or changing how the gamestate is displayed using this method.  If for instance, something in the gamestate triggers a no gravity condtion, then in check conditions, if this returns true, the controller can the getMode().toggleGravity. Note: gravity is yet to be implemented, but rest assured, this is coming, as well as the method toggle gravity!Changing inputs:This is easily done by just writing the exact input methods, as specified by the input team, directly in the controller.  These inputs can do basically that the particular Mode’s API lets you alter!Changing the stats displayed:This is done by subclassing both the level controller, and to subclass the gameloopinfo.  Then, in your new controller’s initializeRest, you will need to instantiate your subclass of displayloopinfo.  In this subclass of displayloopinfo, you can really put any stats you so choose, and this will keep track of them, and display them if you use our given format (annotating them as shown in gameloopinfo). Unfortunately, if you are so ambitious as to display more stats than what we have provided, one must annotate the private instance variable in your subclass, and then subclass HudBuilder, modifying it to look for those particular variable.Changing Level Progression:If you would like to change the level progression, you simply must subclass the GameManager, overwriting the one makeProgession method, and then return a subclassed version of ControlProgressionManager.  All controllerprogression manager does is check for a given Controller name, and returns the specific controller, if found, so should the game developer want to modify this to include a SuperAwesomeTourneyProgression, he/she need only to overwrite this method of ControlProgressionManager, instructing to go through the keyset of controllers, inquiring if they derive from an instance of LevelController.Modifying our LevelMode, which is currently set up to support a fighting game with controllable characters, is done by subclassing either LevelMode, and subclassing Controller, making sure that the loadMode method appropriately instantiates your subclassed mode.  For learning more about what one can do with subclassing The modes and adding new objects to Modes, read on.MenuMode:For changing the Menu Objects themselves, which are the cute little boxes you click on, most changes: image, value, getNext(), can all be modified via xml (see changing object properties).In order to change the grid layout, on must subclass MenuMode (and the controller to provide an entry point for MenuMode. Then one can subclass MenuGrid and create their own algorithm for laying out the different Menus.  One can also add in Character objects into the MenuMode, and so one could potentially have a character attack pick certain menus!XMLChanging object propertiesOur framework is currently set up to be able to incorporate basic characters with simple attacks or basic maps with platforms. To change these such properties of an object in the game, one can simply edit the value of the property in the xml file that, that object is located in.  To edit the speed or health of a character for an example, you may could just change maxHealth or movespeed property in the XML code.  <character charID="Ken" charName="Ken" charIcon="kenicon.png" maxHealth="100" movespeed="15">Starting positions are contained inside the map loader, so if you wish to change the starting location of a character object simply edit the values of xCoord or yCoord, where the first values are associated with the first character and the second values are associated with the second character.         <startingPos xCoord="140" yCoord="300"/>       <startingPos xCoord="200" yCoord="300"/>Adding charactersTo add a character, one should specify the charID, charName, char image, health, and speed.  One should also input all specify details of all the frames that, that character will contain and attacks that that character can perform.  You must also specify the starting location of the character in the maps.xml file by adding a new starting position like so: <startingPos xCoord="200" yCoord="360"/>Here is an example of a character.   <character charID="Ryu" charName="Ryu" charIcon="ryuicon.png" maxHealth="100" movespeed="15">       <state stateName="stand">           <frame image="fighter/images/ryu_stand1.png">               <hitbox cornerX="10" cornerY="3" rectX="28" rectY="78"/>           </frame>       </state>       <state stateName="weakPunch">           <frame image="fighter/images/ryu_punch1.png">               <hitbox cornerX="10" cornerY="3" rectX="35" rectY="78"/>           </frame>           <frame image="fighter/images/ryu_punch2.png">               <hitbox cornerX="10" cornerY="3" rectX="35" rectY="78"/>           </frame>       </state>       <attack attackName="weakPunch" damage="5" duration="20">           <frame image="fighter/images/ken_punch1.png">               <hitbox cornerX="35" cornerY="14" rectX="10" rectY="10"/>           </frame>           <frame image="fighter/images/ken_punch1.png">               <hitbox cornerX="35" cornerY="14" rectX="26" rectY="10"/>           </frame>           <frame image="fighter/images/ken_punch1.png">               <hitbox cornerX="35" cornerY="14" rectX="10" rectY="10"/>           </frame>       </attack>   </character>Adding attacksTo add attacks for a character, one can add an attack inside the character xml like so: <character charID="Ken" charName="Ken" charIcon="kenicon.png" maxHealth="100" movespeed="15">       <attack attackName="weakPunch" damage="5" duration="20">           <frame image="fighter/images/ken_punch1.png">               <hitbox cornerX="35" cornerY="14" rectX="10" rectY="10"/>           </frame>           <frame image="fighter/images/ken_punch1.png">               <hitbox cornerX="35" cornerY="14" rectX="26" rectY="10"/>           </frame>           <frame image="fighter/images/ken_punch1.png">               <hitbox cornerX="35" cornerY="14" rectX="10" rectY="10"/>           </frame>       </attack></character>Adding statesTo add a state, one must specify the frame’s image location and a hitbox like so inside an object:<object objectProperties....><state stateName="weakPunch">           <frame image="fighter/images/ryu_punch1.png">               <hitbox cornerX="10" cornerY="3" rectX="35" rectY="78"/>           </frame>           <frame image="fighter/images/ryu_punch2.png">               <hitbox cornerX="10" cornerY="3" rectX="35" rectY="78"/>           </frame>           <frame image="fighter/images/ryu_punch3.png">               <hitbox cornerX="10" cornerY="3" rectX="35" rectY="78"/>           </frame>       </state></object>	Adding Maps and Environment Objects:Adding Maps or environment objects follow the same patterns as adding character objects.  In environment and map objects it is not necessary to specify health or speed, and obviously do not include any attacks.  However, in map xml files it’s important to remember to add starting positions of character objects.  Here’s an example of a map xml file:<?xml version="1.0"?><maps>   <map mapName="BlueMap" xSize="1024" ySize="871">       <startingPos xCoord="140" yCoord="300"/>       <startingPos xCoord="200" yCoord="300"/>       <state stateName = "background">           <frame image = "fighter/images/BlueBackground.jpeg" />       </state>   </map>   <map mapName="RainbowBackground" xSize="1024" ySize="871">       <startingPos xCoord="140" yCoord="300"/>       <startingPos xCoord="200" yCoord="300"/>       <state stateName = "background">           <frame image = "fighter/images/RainbowBackground.jpeg" />       </state>   </map></maps>Here’s an example of an environment object xml:<environmentObjects>   <environmentObject objectName="platform">       <state stateName = "default">           <frame image="fighter/images/brick1.gif">               <hitbox cornerX="0" cornerY="0" rectX="70" rectY="20"/>           </frame>       </state>   </environmentObject></environmentObjects>When trying to add new objects to game play, one has to subclass LevelMode and then to:Add new types of objects:Say a developer wants to create a new type of GameObject. To do this, the GameObject class must be extended by the new type of object. Within the new GameObject, the developer can override the completeUpdate() method and shouldBeRemoved() method. The first method is used to apply any update logic necessary besides updating states and applying movement vectors. Note that these two operations are covered in superclass methods. The second method should return true when the object in question should be removed from the mode.To add collision behavior for the new object the developer needs to extend CollisionManager and add new collide() methods that take in as parameters the new type of object and whatever it has collision behavior with. Note that TWO collide methods should be written, one with the new object as the first parameter and one with the new object as the second parameter. If there are other types of objects with which the new type of object has no collision interaction, it is not necessary to write a collide() method for that type of interaction.To use the new objects in a Mode, the developer can extend the Mode class as appropriate to make use of the new type of object.The developer is certainly free to use any of the object utils in writing behavior for the new type of object. Additionally, the developer can write additional utils, and is encouraged to do so for behaviors that can be easily focused in some delegate object.